# Generated from /Users/apple/Development/tiny-py-interpreter/parser/TinyPy.g4 by ANTLR 4.5.1
# encoding: utf-8
from io import StringIO

from antlr4 import *


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3\34")
        buf.write("\u00ab\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\3\2\7\2)\n\2\f\2\16\2,\13\2\3\2\3\2\3\3\3\3\3\4\3")
        buf.write("\4\3\4\7\4\65\n\4\f\4\16\48\13\4\3\4\5\4;\n\4\3\4\3\4")
        buf.write("\3\5\3\5\5\5A\n\5\3\6\3\6\3\6\7\6F\n\6\f\6\16\6I\13\6")
        buf.write("\3\7\3\7\3\7\7\7N\n\7\f\7\16\7Q\13\7\3\7\5\7T\n\7\3\b")
        buf.write("\3\b\3\b\7\bY\n\b\f\b\16\b\\\13\b\3\t\3\t\3\t\7\ta\n\t")
        buf.write("\f\t\16\td\13\t\3\n\3\n\3\n\7\ni\n\n\f\n\16\nl\13\n\3")
        buf.write("\13\3\13\3\13\3\13\3\13\7\13s\n\13\f\13\16\13v\13\13\3")
        buf.write("\f\3\f\3\f\3\f\3\f\7\f}\n\f\f\f\16\f\u0080\13\f\3\r\3")
        buf.write("\r\3\r\3\r\3\r\3\r\3\r\7\r\u0089\n\r\f\r\16\r\u008c\13")
        buf.write("\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u0095\n\16")
        buf.write("\3\17\3\17\3\17\6\17\u009a\n\17\r\17\16\17\u009b\3\17")
        buf.write("\3\17\3\17\5\17\u00a1\n\17\3\20\3\20\3\21\3\21\3\22\3")
        buf.write("\22\3\23\3\23\3\23\2\2\24\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write("\32\34\36 \"$\2\3\3\2\23\24\u00b3\2*\3\2\2\2\4/\3\2\2")
        buf.write("\2\6\61\3\2\2\2\b@\3\2\2\2\nB\3\2\2\2\fJ\3\2\2\2\16U\3")
        buf.write("\2\2\2\20]\3\2\2\2\22e\3\2\2\2\24m\3\2\2\2\26w\3\2\2\2")
        buf.write("\30\u0081\3\2\2\2\32\u0094\3\2\2\2\34\u00a0\3\2\2\2\36")
        buf.write("\u00a2\3\2\2\2 \u00a4\3\2\2\2\"\u00a6\3\2\2\2$\u00a8\3")
        buf.write("\2\2\2&)\7\31\2\2\')\5\4\3\2(&\3\2\2\2(\'\3\2\2\2),\3")
        buf.write("\2\2\2*(\3\2\2\2*+\3\2\2\2+-\3\2\2\2,*\3\2\2\2-.\7\2\2")
        buf.write("\3.\3\3\2\2\2/\60\5\6\4\2\60\5\3\2\2\2\61\66\5\b\5\2\62")
        buf.write("\63\7\3\2\2\63\65\5\b\5\2\64\62\3\2\2\2\658\3\2\2\2\66")
        buf.write("\64\3\2\2\2\66\67\3\2\2\2\67:\3\2\2\28\66\3\2\2\29;\7")
        buf.write("\3\2\2:9\3\2\2\2:;\3\2\2\2;<\3\2\2\2<=\7\31\2\2=\7\3\2")
        buf.write("\2\2>A\5\n\6\2?A\5$\23\2@>\3\2\2\2@?\3\2\2\2A\t\3\2\2")
        buf.write("\2BG\5\f\7\2CD\7\4\2\2DF\5\f\7\2EC\3\2\2\2FI\3\2\2\2G")
        buf.write("E\3\2\2\2GH\3\2\2\2H\13\3\2\2\2IG\3\2\2\2JO\5\16\b\2K")
        buf.write("L\7\5\2\2LN\5\16\b\2MK\3\2\2\2NQ\3\2\2\2OM\3\2\2\2OP\3")
        buf.write("\2\2\2PS\3\2\2\2QO\3\2\2\2RT\7\5\2\2SR\3\2\2\2ST\3\2\2")
        buf.write("\2T\r\3\2\2\2UZ\5\20\t\2VW\7\6\2\2WY\5\20\t\2XV\3\2\2")
        buf.write("\2Y\\\3\2\2\2ZX\3\2\2\2Z[\3\2\2\2[\17\3\2\2\2\\Z\3\2\2")
        buf.write("\2]b\5\22\n\2^_\7\7\2\2_a\5\22\n\2`^\3\2\2\2ad\3\2\2\2")
        buf.write("b`\3\2\2\2bc\3\2\2\2c\21\3\2\2\2db\3\2\2\2ej\5\24\13\2")
        buf.write("fg\7\b\2\2gi\5\24\13\2hf\3\2\2\2il\3\2\2\2jh\3\2\2\2j")
        buf.write("k\3\2\2\2k\23\3\2\2\2lj\3\2\2\2mt\5\26\f\2no\7\t\2\2o")
        buf.write("s\5\26\f\2pq\7\n\2\2qs\5\26\f\2rn\3\2\2\2rp\3\2\2\2sv")
        buf.write("\3\2\2\2tr\3\2\2\2tu\3\2\2\2u\25\3\2\2\2vt\3\2\2\2w~\5")
        buf.write("\30\r\2xy\7\13\2\2y}\5\30\r\2z{\7\f\2\2{}\5\30\r\2|x\3")
        buf.write("\2\2\2|z\3\2\2\2}\u0080\3\2\2\2~|\3\2\2\2~\177\3\2\2\2")
        buf.write("\177\27\3\2\2\2\u0080~\3\2\2\2\u0081\u008a\5\32\16\2\u0082")
        buf.write("\u0083\7\r\2\2\u0083\u0089\5\32\16\2\u0084\u0085\7\16")
        buf.write("\2\2\u0085\u0089\5\32\16\2\u0086\u0087\7\17\2\2\u0087")
        buf.write("\u0089\5\32\16\2\u0088\u0082\3\2\2\2\u0088\u0084\3\2\2")
        buf.write("\2\u0088\u0086\3\2\2\2\u0089\u008c\3\2\2\2\u008a\u0088")
        buf.write("\3\2\2\2\u008a\u008b\3\2\2\2\u008b\31\3\2\2\2\u008c\u008a")
        buf.write("\3\2\2\2\u008d\u008e\7\13\2\2\u008e\u0095\5\32\16\2\u008f")
        buf.write("\u0090\7\f\2\2\u0090\u0095\5\32\16\2\u0091\u0092\7\20")
        buf.write("\2\2\u0092\u0095\5\32\16\2\u0093\u0095\5\34\17\2\u0094")
        buf.write("\u008d\3\2\2\2\u0094\u008f\3\2\2\2\u0094\u0091\3\2\2\2")
        buf.write("\u0094\u0093\3\2\2\2\u0095\33\3\2\2\2\u0096\u00a1\7\21")
        buf.write("\2\2\u0097\u00a1\5\36\20\2\u0098\u009a\5\"\22\2\u0099")
        buf.write("\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u0099\3\2\2\2")
        buf.write("\u009b\u009c\3\2\2\2\u009c\u00a1\3\2\2\2\u009d\u00a1\7")
        buf.write("\26\2\2\u009e\u00a1\7\27\2\2\u009f\u00a1\7\30\2\2\u00a0")
        buf.write("\u0096\3\2\2\2\u00a0\u0097\3\2\2\2\u00a0\u0099\3\2\2\2")
        buf.write("\u00a0\u009d\3\2\2\2\u00a0\u009e\3\2\2\2\u00a0\u009f\3")
        buf.write("\2\2\2\u00a1\35\3\2\2\2\u00a2\u00a3\5 \21\2\u00a3\37\3")
        buf.write("\2\2\2\u00a4\u00a5\t\2\2\2\u00a5!\3\2\2\2\u00a6\u00a7")
        buf.write("\7\22\2\2\u00a7#\3\2\2\2\u00a8\u00a9\7\25\2\2\u00a9%\3")
        buf.write("\2\2\2\26(*\66:@GOSZbjrt|~\u0088\u008a\u0094\u009b\u00a0")
        return buf.getvalue()


class TinyPyParser ( Parser ):

    grammarFileName = "TinyPy.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'='", "','", "'|'", "'^'", "'&'", 
                     "'<<'", "'>>'", "'+'", "'-'", "'*'", "'/'", "'%'", 
                     "'~'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'pass'", "'None'", "'True'", "'False'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "NAME", "STRING_LITERAL", 
                      "DECIMAL_INTEGER", "HEX_INTEGER", "PASS", "NONE", 
                      "TRUE", "FALSE", "NEWLINE", "SKIP", "INDENT", "DEDENT" ]

    RULE_file_input = 0
    RULE_stmt = 1
    RULE_simple_stmt = 2
    RULE_small_stmt = 3
    RULE_expr_stmt = 4
    RULE_testlist_expr = 5
    RULE_expr = 6
    RULE_xor_expr = 7
    RULE_and_expr = 8
    RULE_shift_expr = 9
    RULE_arith_expr = 10
    RULE_term = 11
    RULE_factor = 12
    RULE_atom = 13
    RULE_number = 14
    RULE_integer = 15
    RULE_string = 16
    RULE_pass_stmt = 17

    ruleNames =  [ "file_input", "stmt", "simple_stmt", "small_stmt", "expr_stmt", 
                   "testlist_expr", "expr", "xor_expr", "and_expr", "shift_expr", 
                   "arith_expr", "term", "factor", "atom", "number", "integer", 
                   "string", "pass_stmt" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    NAME=15
    STRING_LITERAL=16
    DECIMAL_INTEGER=17
    HEX_INTEGER=18
    PASS=19
    NONE=20
    TRUE=21
    FALSE=22
    NEWLINE=23
    SKIP=24
    INDENT=25
    DEDENT=26

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.5.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class File_inputContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(TinyPyParser.EOF, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(TinyPyParser.NEWLINE)
            else:
                return self.getToken(TinyPyParser.NEWLINE, i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.StmtContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.StmtContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_file_input

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_input" ):
                listener.enterFile_input(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_input" ):
                listener.exitFile_input(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_input" ):
                return visitor.visitFile_input(self)
            else:
                return visitor.visitChildren(self)




    def file_input(self):

        localctx = TinyPyParser.File_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_file_input)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TinyPyParser.T__8) | (1 << TinyPyParser.T__9) | (1 << TinyPyParser.T__13) | (1 << TinyPyParser.NAME) | (1 << TinyPyParser.STRING_LITERAL) | (1 << TinyPyParser.DECIMAL_INTEGER) | (1 << TinyPyParser.HEX_INTEGER) | (1 << TinyPyParser.PASS) | (1 << TinyPyParser.NONE) | (1 << TinyPyParser.TRUE) | (1 << TinyPyParser.FALSE) | (1 << TinyPyParser.NEWLINE))) != 0):
                self.state = 38
                token = self._input.LA(1)
                if token in [TinyPyParser.NEWLINE]:
                    self.state = 36
                    self.match(TinyPyParser.NEWLINE)

                elif token in [TinyPyParser.T__8, TinyPyParser.T__9, TinyPyParser.T__13, TinyPyParser.NAME, TinyPyParser.STRING_LITERAL, TinyPyParser.DECIMAL_INTEGER, TinyPyParser.HEX_INTEGER, TinyPyParser.PASS, TinyPyParser.NONE, TinyPyParser.TRUE, TinyPyParser.FALSE]:
                    self.state = 37
                    self.stmt()

                else:
                    raise NoViableAltException(self)

                self.state = 42
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 43
            self.match(TinyPyParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_stmt(self):
            return self.getTypedRuleContext(TinyPyParser.Simple_stmtContext,0)


        def getRuleIndex(self):
            return TinyPyParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmt" ):
                return visitor.visitStmt(self)
            else:
                return visitor.visitChildren(self)




    def stmt(self):

        localctx = TinyPyParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self.simple_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def small_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.Small_stmtContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.Small_stmtContext,i)


        def NEWLINE(self):
            return self.getToken(TinyPyParser.NEWLINE, 0)

        def getRuleIndex(self):
            return TinyPyParser.RULE_simple_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_stmt" ):
                listener.enterSimple_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_stmt" ):
                listener.exitSimple_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_stmt" ):
                return visitor.visitSimple_stmt(self)
            else:
                return visitor.visitChildren(self)




    def simple_stmt(self):

        localctx = TinyPyParser.Simple_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_simple_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            self.small_stmt()
            self.state = 52
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 48
                    self.match(TinyPyParser.T__0)
                    self.state = 49
                    self.small_stmt() 
                self.state = 54
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 56
            _la = self._input.LA(1)
            if _la==TinyPyParser.T__0:
                self.state = 55
                self.match(TinyPyParser.T__0)


            self.state = 58
            self.match(TinyPyParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Small_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr_stmt(self):
            return self.getTypedRuleContext(TinyPyParser.Expr_stmtContext,0)


        def pass_stmt(self):
            return self.getTypedRuleContext(TinyPyParser.Pass_stmtContext,0)


        def getRuleIndex(self):
            return TinyPyParser.RULE_small_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSmall_stmt" ):
                listener.enterSmall_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSmall_stmt" ):
                listener.exitSmall_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSmall_stmt" ):
                return visitor.visitSmall_stmt(self)
            else:
                return visitor.visitChildren(self)




    def small_stmt(self):

        localctx = TinyPyParser.Small_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_small_stmt)
        try:
            self.state = 62
            token = self._input.LA(1)
            if token in [TinyPyParser.T__8, TinyPyParser.T__9, TinyPyParser.T__13, TinyPyParser.NAME, TinyPyParser.STRING_LITERAL, TinyPyParser.DECIMAL_INTEGER, TinyPyParser.HEX_INTEGER, TinyPyParser.NONE, TinyPyParser.TRUE, TinyPyParser.FALSE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 60
                self.expr_stmt()

            elif token in [TinyPyParser.PASS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 61
                self.pass_stmt()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expr_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def testlist_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.Testlist_exprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.Testlist_exprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_expr_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_stmt" ):
                listener.enterExpr_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_stmt" ):
                listener.exitExpr_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_stmt" ):
                return visitor.visitExpr_stmt(self)
            else:
                return visitor.visitChildren(self)




    def expr_stmt(self):

        localctx = TinyPyParser.Expr_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_expr_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.testlist_expr()
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__1:
                self.state = 65
                self.match(TinyPyParser.T__1)

                self.state = 66
                self.testlist_expr()
                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Testlist_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.ExprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.ExprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_testlist_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestlist_expr" ):
                listener.enterTestlist_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestlist_expr" ):
                listener.exitTestlist_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestlist_expr" ):
                return visitor.visitTestlist_expr(self)
            else:
                return visitor.visitChildren(self)




    def testlist_expr(self):

        localctx = TinyPyParser.Testlist_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_testlist_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.expr()
            self.state = 77
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 73
                    self.match(TinyPyParser.T__2)

                    self.state = 74
                    self.expr() 
                self.state = 79
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 81
            _la = self._input.LA(1)
            if _la==TinyPyParser.T__2:
                self.state = 80
                self.match(TinyPyParser.T__2)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xor_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.Xor_exprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.Xor_exprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = TinyPyParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.xor_expr()
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__3:
                self.state = 84
                self.match(TinyPyParser.T__3)
                self.state = 85
                self.xor_expr()
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Xor_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def and_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.And_exprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.And_exprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_xor_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXor_expr" ):
                listener.enterXor_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXor_expr" ):
                listener.exitXor_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXor_expr" ):
                return visitor.visitXor_expr(self)
            else:
                return visitor.visitChildren(self)




    def xor_expr(self):

        localctx = TinyPyParser.Xor_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_xor_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.and_expr()
            self.state = 96
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__4:
                self.state = 92
                self.match(TinyPyParser.T__4)
                self.state = 93
                self.and_expr()
                self.state = 98
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.Shift_exprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.Shift_exprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_and_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnd_expr" ):
                listener.enterAnd_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnd_expr" ):
                listener.exitAnd_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnd_expr" ):
                return visitor.visitAnd_expr(self)
            else:
                return visitor.visitChildren(self)




    def and_expr(self):

        localctx = TinyPyParser.And_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_and_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.shift_expr()
            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__5:
                self.state = 100
                self.match(TinyPyParser.T__5)
                self.state = 101
                self.shift_expr()
                self.state = 106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arith_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.Arith_exprContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.Arith_exprContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_shift_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_expr" ):
                listener.enterShift_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_expr" ):
                listener.exitShift_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_expr" ):
                return visitor.visitShift_expr(self)
            else:
                return visitor.visitChildren(self)




    def shift_expr(self):

        localctx = TinyPyParser.Shift_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_shift_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.arith_expr()
            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__6 or _la==TinyPyParser.T__7:
                self.state = 112
                token = self._input.LA(1)
                if token in [TinyPyParser.T__6]:
                    self.state = 108
                    self.match(TinyPyParser.T__6)
                    self.state = 109
                    self.arith_expr()

                elif token in [TinyPyParser.T__7]:
                    self.state = 110
                    self.match(TinyPyParser.T__7)
                    self.state = 111
                    self.arith_expr()

                else:
                    raise NoViableAltException(self)

                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.TermContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.TermContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_arith_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArith_expr" ):
                listener.enterArith_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArith_expr" ):
                listener.exitArith_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArith_expr" ):
                return visitor.visitArith_expr(self)
            else:
                return visitor.visitChildren(self)




    def arith_expr(self):

        localctx = TinyPyParser.Arith_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_arith_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.term()
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TinyPyParser.T__8 or _la==TinyPyParser.T__9:
                self.state = 122
                token = self._input.LA(1)
                if token in [TinyPyParser.T__8]:
                    self.state = 118
                    self.match(TinyPyParser.T__8)
                    self.state = 119
                    self.term()

                elif token in [TinyPyParser.T__9]:
                    self.state = 120
                    self.match(TinyPyParser.T__9)
                    self.state = 121
                    self.term()

                else:
                    raise NoViableAltException(self)

                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.FactorContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.FactorContext,i)


        def getRuleIndex(self):
            return TinyPyParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = TinyPyParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.factor()
            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TinyPyParser.T__10) | (1 << TinyPyParser.T__11) | (1 << TinyPyParser.T__12))) != 0):
                self.state = 134
                token = self._input.LA(1)
                if token in [TinyPyParser.T__10]:
                    self.state = 128
                    self.match(TinyPyParser.T__10)
                    self.state = 129
                    self.factor()

                elif token in [TinyPyParser.T__11]:
                    self.state = 130
                    self.match(TinyPyParser.T__11)
                    self.state = 131
                    self.factor()

                elif token in [TinyPyParser.T__12]:
                    self.state = 132
                    self.match(TinyPyParser.T__12)
                    self.state = 133
                    self.factor()

                else:
                    raise NoViableAltException(self)

                self.state = 138
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(TinyPyParser.FactorContext,0)


        def atom(self):
            return self.getTypedRuleContext(TinyPyParser.AtomContext,0)


        def getRuleIndex(self):
            return TinyPyParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = TinyPyParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_factor)
        try:
            self.state = 146
            token = self._input.LA(1)
            if token in [TinyPyParser.T__8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.match(TinyPyParser.T__8)
                self.state = 140
                self.factor()

            elif token in [TinyPyParser.T__9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(TinyPyParser.T__9)
                self.state = 142
                self.factor()

            elif token in [TinyPyParser.T__13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 143
                self.match(TinyPyParser.T__13)
                self.state = 144
                self.factor()

            elif token in [TinyPyParser.NAME, TinyPyParser.STRING_LITERAL, TinyPyParser.DECIMAL_INTEGER, TinyPyParser.HEX_INTEGER, TinyPyParser.NONE, TinyPyParser.TRUE, TinyPyParser.FALSE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 145
                self.atom()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(TinyPyParser.NAME, 0)

        def number(self):
            return self.getTypedRuleContext(TinyPyParser.NumberContext,0)


        def string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TinyPyParser.StringContext)
            else:
                return self.getTypedRuleContext(TinyPyParser.StringContext,i)


        def NONE(self):
            return self.getToken(TinyPyParser.NONE, 0)

        def TRUE(self):
            return self.getToken(TinyPyParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(TinyPyParser.FALSE, 0)

        def getRuleIndex(self):
            return TinyPyParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = TinyPyParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.state = 158
            token = self._input.LA(1)
            if token in [TinyPyParser.NAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 148
                self.match(TinyPyParser.NAME)

            elif token in [TinyPyParser.DECIMAL_INTEGER, TinyPyParser.HEX_INTEGER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 149
                self.number()

            elif token in [TinyPyParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 151 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 150
                    self.string()
                    self.state = 153 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==TinyPyParser.STRING_LITERAL):
                        break


            elif token in [TinyPyParser.NONE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 155
                self.match(TinyPyParser.NONE)

            elif token in [TinyPyParser.TRUE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 156
                self.match(TinyPyParser.TRUE)

            elif token in [TinyPyParser.FALSE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 157
                self.match(TinyPyParser.FALSE)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(TinyPyParser.IntegerContext,0)


        def getRuleIndex(self):
            return TinyPyParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = TinyPyParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL_INTEGER(self):
            return self.getToken(TinyPyParser.DECIMAL_INTEGER, 0)

        def HEX_INTEGER(self):
            return self.getToken(TinyPyParser.HEX_INTEGER, 0)

        def getRuleIndex(self):
            return TinyPyParser.RULE_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger" ):
                listener.enterInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger" ):
                listener.exitInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger" ):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)




    def integer(self):

        localctx = TinyPyParser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_integer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            _la = self._input.LA(1)
            if not(_la==TinyPyParser.DECIMAL_INTEGER or _la==TinyPyParser.HEX_INTEGER):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(TinyPyParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return TinyPyParser.RULE_string

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString" ):
                listener.enterString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString" ):
                listener.exitString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitString" ):
                return visitor.visitString(self)
            else:
                return visitor.visitChildren(self)




    def string(self):

        localctx = TinyPyParser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(TinyPyParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pass_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASS(self):
            return self.getToken(TinyPyParser.PASS, 0)

        def getRuleIndex(self):
            return TinyPyParser.RULE_pass_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPass_stmt" ):
                listener.enterPass_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPass_stmt" ):
                listener.exitPass_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPass_stmt" ):
                return visitor.visitPass_stmt(self)
            else:
                return visitor.visitChildren(self)




    def pass_stmt(self):

        localctx = TinyPyParser.Pass_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_pass_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(TinyPyParser.PASS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





